;;; -*- Mode: Lisp; common-lisp-style: poem -*-

;;; Copyright (c) 2012 Matthias HÃ¶lzl
;;; 
;;; This file is licensed under the MIT license; see the file LICENSE
;;; in the root directory for further information.

(in-package #:odysseus)

(in-suite odysseus-syntax-suite)

(deftest test-singleton-terms-mixin ()
  (let ((stm (make-instance 'singleton-terms-mixin)))
    (is (null (slot-value stm 'the-empty-program-term)))
    (is (null (slot-value stm 'the-no-operation-term)))
    (is (typep (the-empty-program-term stm) 'empty-program-term))
    (is (typep (the-no-operation-term stm) 'no-operation-term))
    (is (eql (the-empty-program-term stm) (the-empty-program-term stm)))
    (is (eql (the-no-operation-term stm) (the-no-operation-term stm)))))

(defclass uniquely-named-term (term-with-unique-name-mixin name-mixin)
  ())

(deftest test-add-to-terms-with-unique-names ()
  (let ((cc (make-instance 'terms-with-unique-names-mixin))
        (t1 (make-instance 'uniquely-named-term :name :t1))
        (t2 (make-instance 'uniquely-named-term :name :t2))
        (t3 (make-instance 'uniquely-named-term :name :t1)))
    (is (null (position t1 (terms-with-unique-names cc))))
    (not-signals warning (add-to-terms-with-unique-names t1 cc))
    (is (= 0 (position t1 (terms-with-unique-names cc))))
    (not-signals warning (add-to-terms-with-unique-names t2 cc))
    (is (= 0 (position t1 (terms-with-unique-names cc))))
    (is (= 1 (position t2 (terms-with-unique-names cc))))
    (is (null (position t3 (terms-with-unique-names cc))))
    (not-signals warning (add-to-terms-with-unique-names t3 cc))
    (is (null (position t1 (terms-with-unique-names cc))))
    (is (= 1 (position t2 (terms-with-unique-names cc))))
    (is (= 0 (position t3 (terms-with-unique-names cc))))))

(deftest test-shared-initialize-for-compilation-unit ()
  (let ((cu (make-instance 'compilation-unit)))
    (iterate (for known-operator-name in (hash-table-keys (default-known-operators)))
      (is (typep (term-type-for-operator known-operator-name cu)
                 'symbol)))
    (iterate (for action-name in *default-primitive-action-names*)
      (is (typep (primitive-action-definition action-name cu)
                 'primitive-action-definition)))))


(deftest test-global-lookup-for-variable ()
  (let* ((cu (make-instance 'compilation-unit))
         (vars (odysseus::variable-hash-table cu)))
    (is (= (hash-table-count vars) 0))
    (is (eql (lookup-variable 'foo 'foo-sort cu nil) nil))
    (is (= (hash-table-count vars) 0))
    (let ((foo (lookup-variable 'foo 'foo-sort cu t))
          (bar (make-instance 'variable-term
                              :name 'bar :sort 'bar-sort :intern nil
                              :context cu)))
      (is (= (hash-table-count vars) 1))
      (is (eql (gethash 'foo vars) foo))
      (is (eql (lookup-variable 'foo 'foo-sort cu) foo))
      (setf (lookup-variable 'bar 'bar-sort cu) bar)
      (is (= (hash-table-count vars) 2))
      (is (eql (gethash 'bar vars) bar))
      (is (eql (lookup-variable 'bar 'bar-sort cu) bar))
      (is (eql (gethash 'foo vars) foo))
      (is (eql (lookup-variable 'foo 'foo-sort cu) foo)))))

(deftest test-local-lookup-for-variable ()
  (let* ((cu (make-instance 'compilation-unit))
         (vars (odysseus::variable-hash-table cu))
         (lc (make-instance 'local-context :enclosing-context cu)))
    (is (eql (local-variables lc) '()))
    (is (eql (lookup-variable 'foo 'foo-sort lc nil) nil))
    (is (eql (local-variables lc) '()))
    (let ((foo (lookup-variable 'foo 'foo-sort lc t))
          (bar (make-instance 'variable-term
                              :name 'bar :intern nil
                              :context lc))
          (baz (make-instance 'variable-term
                              :name 'baz :intern nil
                              :context lc)))
      (is (equalp (local-variables lc) (list (cons 'foo foo))))
      (is (= (hash-table-count vars) 0))
      (is (eql foo (lookup-variable 'foo 'foo-sort lc nil)))
      (is (eql nil (lookup-variable 'bar 'bar-sort lc nil)))
      (is (eql nil (lookup-variable 'baz 'baz-sort lc nil)))

      (setf (lookup-variable 'bar 'bar-sort lc) bar)
      (is (= (hash-table-count vars) 0))
      (is (equalp (assoc 'bar (local-variables lc)) (cons 'bar bar)))
      (is (eql foo (lookup-variable 'foo 'foo-sort lc nil)))
      (is (eql bar (lookup-variable 'bar 'bar-sort lc nil)))
      (is (eql nil (lookup-variable 'baz 'baz-sort lc nil)))

      (setf (lookup-variable 'baz 'baz-sort cu) baz)
      (is (= (hash-table-count vars) 1))
      (is (eql foo (lookup-variable 'foo 'foo-sort lc nil)))
      (is (eql bar (lookup-variable 'bar 'bar-sort lc nil)))
      (is (eql baz (lookup-variable 'baz 'baz-sort lc nil)))
      (is (eql nil (lookup-variable 'foo 'foo-sort cu nil)))
      (is (eql nil (lookup-variable 'bar 'bar-sort cu nil)))
      (is (eql baz (lookup-variable 'baz 'baz-sort cu nil))))))



(deftest test-variable-interning-in-compilation-unit ()
  (let ((cu (make-instance 'compilation-unit)))
    (is (eq (make-instance 'variable-term :name 'f :context cu)
		(make-instance 'variable-term :name 'f :context cu)))
    (is (eq (make-instance 'variable-term :name 'g :context cu)
		(make-instance 'variable-term :name 'g :context cu)))
    (is (not (eq (make-instance 'variable-term :name 'f :context cu)
		     (make-instance 'variable-term :name 'g :context cu))))))

(deftest test-global-lookup-for-number ()
  (let* ((cu (make-instance 'compilation-unit))
         (nums (odysseus::number-hash-table cu)))
    (is (= (hash-table-count nums) 0))
    (is (eql (lookup-number 1 cu nil) nil))
    (is (= (hash-table-count nums) 0))
    (let ((foo (lookup-number 1 cu t))
          (bar (make-instance
                'number-term :value 2 :intern nil :context cu)))
      (is (= (hash-table-count nums) 1))
      (is (eql (gethash 1 nums) foo))
      (is (eql (lookup-number 1 cu) foo))
      (setf (lookup-number 2 cu) bar)
      (is (= (hash-table-count nums) 2))
      (is (eql (gethash 2 nums) bar))
      (is (eql (lookup-number 2 cu) bar))
      (is (eql (gethash 1 nums) foo))
      (is (eql (lookup-number 1 cu) foo)))))

(deftest test-local-lookup-for-number ()
  (let* ((cu (make-instance 'compilation-unit))
         (lc (make-instance 'local-context :enclosing-context cu)))
    (is (eql (lookup-number 123 lc nil) nil))
    (let ((n234 (lookup-number 234 lc t))
          (n345 (make-instance
                 'number-term :value 345 :intern nil :context lc)))
      (is (eql n234 (lookup-number 234 lc nil)))
      (is (eql nil  (lookup-number 345 lc nil)))

      (setf (lookup-number 345 cu) n345)
      (is (eql n234 (lookup-number 234 lc nil)))
      (is (eql n345 (lookup-number 345 lc nil)))
      (is (eql nil  (lookup-number 456 lc nil)))
      (is (eql n234 (lookup-number 234 cu nil)))
      (is (eql n345 (lookup-number 345 cu nil)))
      (is (eql nil  (lookup-number 456 cu nil))))))

(deftest test-number-interning-in-compilation-unit ()
  (let ((cu (make-instance 'compilation-unit)))
    (is (not (eq (make-instance 'number-term :value 0 :context cu :intern nil)
		     (make-instance 'number-term :value 0 :context cu :intern nil))))
    (is (eq (make-instance 'number-term :value 0 :context cu)
		(make-instance 'number-term :value 0 :context cu)))
    (is (eq (make-instance 'number-term :value 1 :context cu)
		(make-instance 'number-term :value 1 :context cu)))
    (is (not (eq (make-instance 'number-term :value 0 :context cu)
		     (make-instance 'number-term :value 1 :context cu))))))

(deftest test-global-lookup-for-functor ()
  (let* ((cu (make-instance 'compilation-unit))
         (funs (odysseus::functor-hash-table cu)))
    (is (= (hash-table-count funs) 0))
    (is (eql (lookup-functor 'foo 2 cu nil) nil))
    (let ((foo/2 (lookup-functor 'foo 2 cu t))
          (foo/3 (lookup-functor 'foo 3 cu t))
          (bar (make-instance
                'functor-term :name 'bar :arity 3 :context cu :intern nil)))
      (is (= (hash-table-count funs) 1))
      (is (not (eql foo/2 foo/3)))
      (is (eql (lookup-functor 'foo 2 cu) foo/2))
      (setf (lookup-functor 'bar 3 cu) bar)
      (is (= (hash-table-count funs) 2))
      (is (eql (lookup-functor 'bar 3 cu) bar))
      (is (eql (lookup-functor 'foo 2 cu) foo/2)))))

(deftest test-local-lookup-for-functor ()
  (let* ((cu (make-instance 'compilation-unit))
         (funs (odysseus::functor-hash-table cu))
         (lc (make-instance 'local-context :enclosing-context cu)))
    (is (= (hash-table-count funs) 0))
    (is (eql (lookup-functor 'foo 2 lc nil) nil))
    (let ((foo/2 (lookup-functor 'foo 2 lc t))
          (foo/3 (lookup-functor 'foo 3 lc t))
          (bar (make-instance
                'functor-term :name 'bar :arity 3 :context lc :intern nil)))
      (is (= (hash-table-count funs) 1))
      (is (not (eql foo/2 foo/3)))
      (is (eql (lookup-functor 'foo 2 lc) foo/2))
      (setf (lookup-functor 'bar 3 lc) bar)
      (is (= (hash-table-count funs) 2))
      (is (eql (lookup-functor 'bar 3 lc) bar))
      (is (eql (lookup-functor 'foo 2 lc) foo/2)))))

(deftest test-functor-interning-in-compilation-unit ()
  (let ((cu (make-instance 'compilation-unit)))
    (is (not (eq (make-instance 'functor-term :name 'f :arity 1 :context cu :intern nil)
		     (make-instance 'functor-term :name 'f :arity 1 :context cu :intern nil))))
    (is (eq (make-instance 'functor-term :name 'f :arity 1 :context cu)
		(make-instance 'functor-term :name 'f :arity 1 :context cu)))
    (is (eq (make-instance 'functor-term :name 'f :arity 1 :context cu)
		(make-instance 'functor-term :name 'f :arity 1 :context cu)))
    (is (not (eq (make-instance 'functor-term :name 'f :arity 0 :context cu)
		     (make-instance 'functor-term :name 'f :arity 1 :context cu))))))
